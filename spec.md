**Title**: Structured JSON Table  (SJT) Format Specification

**Version**: 1.0

**Author**: Yuki Akai

**Date**: 2025-07-25

---

# SJT (Structured JSON Table) Format Specification

### Overview

Structured JSON Table (SJT) Format is a compact and bandwidth-efficient data representation designed to encode large, structured datasets—especially those with uniform shape or schema—into a nested, index-driven format. This reduces redundancy and improves serialization/deserialization speed over conventional JSON.

---

### Motivation

Traditional JSON represents each object or array with its full property names, leading to redundant transmission and increased payload size. SJTF separates structure and data, allowing the client and server to reconstruct objects without repeating field names.

---

### Format Structure

The SJT payload is a 2-element array:

```
[ <Header>, <Data> ]
```

* **Header**: A recursive array of strings and nested arrays representing the schema.
* **Data**: An array of records, each record maps to a header schema by position.

### 1. Header (Field Template)

Describes the recursive key structure of each object. It is generated by walking through the first JSON object and collecting key names, maintaining their nesting structure.

* Primitives → strings
* Nested objects → nested arrays of strings
* Arrays of objects → nested arrays of headers

**Example:**

```ts
["id", ["user", ["name", "age"]]]
```

### 2. Data

An array of values extracted from each object in the dataset, following the shape of the Header. For nested objects, the values are grouped accordingly.

**Example:**

```ts
[
  [1, [["Yuki", 24]]],
  [2, [["Aki", 24]]]
]
```

---

### Encoding Algorithm (Server-side)

#### Step 1: Validate Input

* Input must be an array of uniformly structured JSON objects.

#### Step 2: Build Header

* Recursively walk through the first object to collect all keys.
* If a value is a nested object or array of structured objects, recurse and build a nested header.

#### Step 3: Encode Data

* For each object in the array:

  * Extract values in the order and shape defined by the header.
  * Use recursion to navigate into nested structures.

#### Step 4: Output

* Return the final structure:

```ts
[
  Header, // The field template
  Data[]  // Flattened object values in header order
]
```

---

### Decoding Algorithm (Client-side)

#### Step 1: Read Header and Data

* Extract header and data entries from the 2-element array.

#### Step 2: Rebuild Objects

* For each entry in the data array:

  * Recursively apply keys from the header to inject values into new objects.

#### Step 3: Output

* Return an array of fully reconstructed JSON objects.

---

### Constraints

* The structure must be **uniform** across all entries.
* Header keys must be **valid JSON object keys**.
* Mixed-type fields or varying structures across entries are **not supported** in this version.

---

### Advantages

* Minimizes repeated keys → smaller payload size.
* Easy to cache structure separately.
* Fast deserialization with uniform template.
* Ideal for tabular or API responses with fixed schema.

---

### Use Cases

* APIs with large paginated results (e.g., Discord, Google).
* Event logs or metrics.
* Realtime streaming of structured data.

---
